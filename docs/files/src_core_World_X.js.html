<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\core\World_X.js - oimo</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="..\..\examples\assets\img\logo-docs.png" title="oimo"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/BoxShape.html">BoxShape</a></li>
                                <li><a href="../classes/CylinderShape.html">CylinderShape</a></li>
                                <li><a href="../classes/MassInfo.html">MassInfo</a></li>
                                <li><a href="../classes/Proxy.html">Proxy</a></li>
                                <li><a href="../classes/Shape.html">Shape</a></li>
                                <li><a href="../classes/ShapeConfig.html">ShapeConfig</a></li>
                                <li><a href="../classes/SphereShape.html">SphereShape</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\core\World_X.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { SHAPE_BOX, SHAPE_SPHERE, SHAPE_CYLINDER, BODY_DYNAMIC, BODY_STATIC } from &#x27;../constants&#x27;;
import { Performance, Error } from &#x27;./Utils&#x27;;


import { BruteForceBroadPhase } from &#x27;../collision/broadphase/BruteForceBroadPhase_X&#x27;;
import { SAPBroadPhase } from &#x27;../collision/broadphase/sap/SAPBroadPhase_X&#x27;;
import { DBVTBroadPhase } from &#x27;../collision/broadphase/dbvt/DBVTBroadPhase_X&#x27;;

import { BoxBoxCollisionDetector } from &#x27;../collision/narrowphase/BoxBoxCollisionDetector&#x27;;
import { BoxCylinderCollisionDetector } from &#x27;../collision/narrowphase/BoxCylinderCollisionDetector&#x27;;
import { CylinderCylinderCollisionDetector } from &#x27;../collision/narrowphase/CylinderCylinderCollisionDetector&#x27;;
import { SphereBoxCollisionDetector } from &#x27;../collision/narrowphase/SphereBoxCollisionDetector&#x27;;
import { SphereCylinderCollisionDetector } from &#x27;../collision/narrowphase/SphereCylinderCollisionDetector&#x27;;
import { SphereSphereCollisionDetector } from &#x27;../collision/narrowphase/SphereSphereCollisionDetector&#x27;;
//import { TetraTetraCollisionDetector } from &#x27;../collision/narrowphase/TetraTetraCollisionDetector&#x27;;

import { _Math } from &#x27;../math/Math&#x27;;
import { Mat33 } from &#x27;../math/Mat33&#x27;;
import { Quat } from &#x27;../math/Quat&#x27;;
import { Vec3 } from &#x27;../math/Vec3&#x27;;

import { ShapeConfig } from &#x27;../collision/shape/ShapeConfig&#x27;;
import { BoxShape } from &#x27;../collision/shape/BoxShape&#x27;;
import { SphereShape } from &#x27;../collision/shape/SphereShape&#x27;;
import { CylinderShape } from &#x27;../collision/shape/CylinderShape&#x27;;
//import { TetraShape } from &#x27;../collision/shape/TetraShape&#x27;;

import { Contact } from &#x27;../constraint/contact/Contact_X&#x27;;

import { JointConfig } from &#x27;../constraint/joint/JointConfig&#x27;;
import { HingeJoint } from &#x27;../constraint/joint/HingeJoint&#x27;;
import { BallAndSocketJoint } from &#x27;../constraint/joint/BallAndSocketJoint&#x27;;
import { DistanceJoint } from &#x27;../constraint/joint/DistanceJoint&#x27;;
import { PrismaticJoint } from &#x27;../constraint/joint/PrismaticJoint&#x27;;
import { SliderJoint } from &#x27;../constraint/joint/SliderJoint&#x27;;
import { WheelJoint } from &#x27;../constraint/joint/WheelJoint&#x27;;

import { RigidBody } from &#x27;./RigidBody_X&#x27;;

/**
 * The class of physical computing world. 
 * You must be added to the world physical all computing objects
 * @author saharan
 * @author lo-th
 */

 // timestep, broadphase, iterations, worldscale, random, stat

function World ( o ) {

    if( !(o instanceof Object) ) o = {};

    // this world scale defaut is 0.1 to 10 meters max for dynamique body
    this.scale = o.worldscale || 1;
    this.invScale = 1/this.scale;

    // The time between each step
    this.timeStep = o.timestep || 0.01666; // 1/60;
    // The number of iterations for constraint solvers.
    this.numIterations = o.iterations || 8;

     // It is a wide-area collision judgment that is used in order to reduce as much as possible a detailed collision judgment.
    switch( o.broadphase || 2 ){
        case 1: this.broadPhase = new BruteForceBroadPhase(); break;
        case 2: default: this.broadPhase = new SAPBroadPhase(); break;
        case 3: this.broadPhase = new DBVTBroadPhase(); break;
    }

    this.Btypes = [&#x27;None&#x27;,&#x27;BruteForce X&#x27;,&#x27;Sweep &amp; Prune X&#x27;, &#x27;Bounding Volume Tree X&#x27; ];
    this.broadPhaseType = this.Btypes[ o.broadphase || 2 ];

    // This is the detailed information of the performance. 
    this.performance = null;
    this.isStat = o.info === undefined ? false : o.info;
    if( this.isStat ) this.performance = new Performance( this );

    // Whether the constraints randomizer is enabled or not.
    this.enableRandomizer = o.random !== undefined ? o.random : true;

    


    // The rigid body list
    this.rigidBodies=[];//null;
    // number of rigid body
    this.numRigidBodies=0;
    // The contact list
    this.contacts=[];//null;
    //this.unusedContacts=null;
    // The number of contact
    this.numContacts=0;
    // The number of contact points
    this.numContactPoints=0;
    //  The joint list
    this.joints=[];//null;
    // The number of joints.
    this.numJoints=0;
    // The number of simulation islands.
    this.numIslands=0;
    
   
    // The gravity in the world.
    this.gravity = new Vec3(0,-9.8,0);
    if( o.gravity !== undefined ) this.gravity.fromArray( o.gravity );

    

    var numShapeTypes = 5;//4;//3;
    this.detectors=[];
    this.detectors.length = numShapeTypes;
    var i = numShapeTypes;
    while(i--){
        this.detectors[i]=[];
        this.detectors[i].length = numShapeTypes;
    }

    this.detectors[SHAPE_SPHERE][SHAPE_SPHERE] = new SphereSphereCollisionDetector();
    this.detectors[SHAPE_SPHERE][SHAPE_BOX] = new SphereBoxCollisionDetector(false);
    this.detectors[SHAPE_BOX][SHAPE_SPHERE] = new SphereBoxCollisionDetector(true);
    this.detectors[SHAPE_BOX][SHAPE_BOX] = new BoxBoxCollisionDetector();

    // CYLINDER add
    this.detectors[SHAPE_CYLINDER][SHAPE_CYLINDER] = new CylinderCylinderCollisionDetector();

    this.detectors[SHAPE_CYLINDER][SHAPE_BOX] = new BoxCylinderCollisionDetector(true);
    this.detectors[SHAPE_BOX][SHAPE_CYLINDER] = new BoxCylinderCollisionDetector(false);

    this.detectors[SHAPE_CYLINDER][SHAPE_SPHERE] = new SphereCylinderCollisionDetector(true);
    this.detectors[SHAPE_SPHERE][SHAPE_CYLINDER] = new SphereCylinderCollisionDetector(false);

    // TETRA add
    //this.detectors[SHAPE_TETRA][SHAPE_TETRA] = new TetraTetraCollisionDetector();

 
    this.randX = 65535;
    this.randA = 98765;
    this.randB = 123456789;

    this.islandRigidBodies = [];
    this.islandStack = [];
    this.islandConstraints = [];

}

Object.assign( World.prototype, {

    World: true,

    getInfo: function(){

        return this.isStat ? this.performance.show() : &#x27;&#x27;;

    },

    /**
    * Reset the randomizer and remove all rigid bodies, shapes, joints and any object from the world.
	*/
    clear:function(){

        this.randX = 65535;

        /*while(this.joints!==null){
            this.removeJoint( this.joints );
        }
        while(this.contacts!==null){
            this.removeContact( this.contacts );
        }
        /*while(this.rigidBodies!==null){
            this.removeRigidBody( this.rigidBodies );
        }*/

        while( this.joints.length &gt; 0 ) this.removeJoint( this.joints.pop() );
        while( this.contacts.length &gt; 0 ) this.removeContact( this.contacts.pop(), true );
        while( this.rigidBodies.length &gt; 0 ) this.removeRigidBody( this.rigidBodies.pop() );

    },
    /**
    * I&#x27;ll add a rigid body to the world. 
    * Rigid body that has been added will be the operands of each step.
    * @param  rigidBody  Rigid body that you want to add
    */
    addRigidBody:function( rigidBody ){

        if( rigidBody.parent ){
            Error(&quot;World&quot;, &quot;It is not possible to be added to more than one world one of the rigid body&quot;);
        }

        rigidBody.setParent( this );

        var i = rigidBody.shapes.length;

        while(i--){

            this.addShape(rigidBody.shapes[i]);

        }

        this.rigidBodies.push( rigidBody );

        this.numRigidBodies = this.rigidBodies.length;

    },
    /**
    * I will remove the rigid body from the world. 
    * Rigid body that has been deleted is excluded from the calculation on a step-by-step basis.
    * @param  rigidBody  Rigid body to be removed
    */
    removeRigidBody:function( rigidBody ){

        var remove = rigidBody;
        if(remove.parent!==this) return;
        remove.awake();

        var i = remove.jointLink.length;
        while(i--){
	        this.removeJoint(remove.jointLink[i]);
        }

        i = remove.shapes.length;
        while(i--){
            this.removeShape(remove.shapes[i]);
        }
        /*var prev=remove.prev;
        var next=remove.next;
        if(prev!==null) prev.next=next;
        if(next!==null) next.prev=prev;
        if(this.rigidBodies==remove) this.rigidBodies=next;
        remove.prev=null;
        remove.next=null;*/
        remove.parent = null;

        this.numRigidBodies = this.rigidBodies.length;
        //this.numRigidBodies--;

    },

    getByName: function( name ){

        var i, body, joint;

        i = this.rigidBodies.length;
        while(i--){
            body = this.rigidBodies[i];
            if( body.name === name ) return body;
        }

        i = this.joints.length;
        while(i--){
            joint = this.joints[i];
            if( joint.name === name ) return joint;
        }

        return null;

    },

    /**
    * I&#x27;ll add a shape to the world..
    * Add to the rigid world, and if you add a shape to a rigid body that has been added to the world, 
    * Shape will be added to the world automatically, please do not call from outside this method.
    * @param  shape  Shape you want to add
    */
    addShape:function ( shape ){

        if(!shape.parent || !shape.parent.parent){
            Error(&quot;World&quot;, &quot;It is not possible to be added alone to shape world&quot;);
        }

        shape.proxy = this.broadPhase.createProxy(shape);
        shape.updateProxy();
        this.broadPhase.addProxy( shape.proxy );

    },

    /**
    * I will remove the shape from the world.
    * Add to the rigid world, and if you add a shape to a rigid body that has been added to the world, 
    * Shape will be added to the world automatically, please do not call from outside this method.
    * @param  shape  Shape you want to delete
    */
    removeShape: function ( shape ){

        this.broadPhase.removeProxy( shape.proxy );
        shape.proxy = null;

    },

    /**
    * I&#x27;ll add a joint to the world. 
    * Joint that has been added will be the operands of each step.
    * @param  shape Joint to be added
    */
    addJoint: function ( joint ) {

        if(joint.parent){
            Error(&quot;World&quot;, &quot;It is not possible to be added to more than one world one of the joint&quot;);
        }
        //if(this.joints!=null)(this.joints.prev=joint).next=this.joints;
        //this.joints=joint;

        joint.parent = this;
        //this.numJoints++;
        joint.awake();
        joint.attach( true );

        this.joints.push( joint );

    },

    /**
    * I will remove the joint from the world. 
    * Joint that has been added will be the operands of each step.
    * @param  shape Joint to be deleted
    */
    removeJoint: function ( joint ) {

        
        /*var prev=remove.prev;
        var next=remove.next;
        if(prev!==null)prev.next=next;
        if(next!==null)next.prev=prev;
        if(this.joints==remove)this.joints=next;
        remove.prev=null;
        remove.next=null;
        this.numJoints--;*/
        joint.awake();
        joint.detach( true );
        joint.parent = null;

    },

    addContact: function ( s1, s2 ) {

        /*var newContact;
        if(this.unusedContacts!==null){
            newContact=this.unusedContacts;
            this.unusedContacts=this.unusedContacts.next;
        }else{
            newContact = new Contact();
        }*/
        var newContact = new Contact();
        newContact.attach( s1, s2 );
        newContact.detector = this.detectors[s1.type][s2.type];
        //if(this.contacts)(this.contacts.prev = newContact).next = this.contacts;
        //this.contacts = newContact;
        this.contacts.push( newContact );

        this.numContacts = this.contacts.length;

        

    },

    removeContact: function ( contact, ar ) {

        if( ar===undefined ) this.contacts.splice( this.contacts.indexOf(contact), 1 );

        //var prev = contact.prev;
        //var next = contact.next;
        //if(next) next.prev = prev;
        //if(prev) prev.next = next;
        //if(this.contacts == contact) this.contacts = next;
        //contact.prev = null;
        //contact.next = null;
        contact.detach();
        //contact.next = this.unusedContacts;
        //this.unusedContacts = contact;
        this.numContacts = this.contacts.length;


    },

    checkContact: function ( name1, name2 ) {

        var n1, n2;
        var i = this.contacts.length, contact;
        while(i--){
            contact = this.contacts[i];
            n1 = contact.body1.name;
            n2 = contact.body2.name;
            if((n1===name1 &amp;&amp; n2===name2) || (n2===name1 &amp;&amp; n1===name2)){ if(contact.touching) return true; else return false;}
        }

        return false;

    },

    callSleep: function( body ) {

        if( !body.allowSleep ) return false;
        if( body.linearVelocity.lengthSq() &gt; 0.04 ) return false;
        if( body.angularVelocity.lengthSq() &gt; 0.25 ) return false;
        return true;

    },

    /**
    * I will proceed only time step seconds time of World.
    */
    step: function () {

        var stat = this.isStat;

        if( stat ) this.performance.setTime( 0 );

        var body, base, contact, i, j, k, cs, js, next;

        i = this.rigidBodies.length;

        while( i-- ){

            body = this.rigidBodies[i]; 
            body.addedToIsland = false;
            if( body.sleeping ) body.testWakeUp();

        }

        

        //------------------------------------------------------
        //   UPDATE BROADPHASE CONTACT
        //------------------------------------------------------
        
        if( stat ) this.performance.setTime( 1 );

        this.broadPhase.detectPairs();

        var pairs = this.broadPhase.pairs;

        i = this.broadPhase.numPairs;
        //do{
        while(i--){
        //for(var i=0, l=numPairs; i&lt;l; i++){
            var pair = pairs[i];
            var s1;
            var s2;
            if(pair.shape1.id&lt;pair.shape2.id){
                s1 = pair.shape1;
                s2 = pair.shape2;
            }else{
                s1 = pair.shape2;
                s2 = pair.shape1;
            }

            var link;
            var s1L = s1.contactLink.length;
            var s2L = s2.contactLink.length;

            if( s1L &lt; s2L ) link = s1.contactLink;
            else link = s2.contactLink;
            
            var exists = false;
            j = link.length;
            while(j--){
                var contact = link[j].contact;
                if( contact.shape1 == s1 &amp;&amp; contact.shape2 == s2 ){
                    contact.persisting = true;
                    exists = true;// contact already exists
                    break;
                }
                //link = link.next;
            }
            if(!exists){
                this.addContact( s1, s2 );
            }
        }// while(i-- &gt;0);

        if( stat ) this.performance.calcBroadPhase();

        //------------------------------------------------------
        //   UPDATE NARROWPHASE CONTACT
        //------------------------------------------------------

        // update &amp; narrow phase
        this.numContactPoints = 0;
        //contact = this.contacts;
        i = this.contacts.length;
        while( i-- ){
            contact = this.contacts[i];
        //while( contact!==null ){
            if(!contact.persisting){
                if ( contact.shape1.aabb.intersectTest( contact.shape2.aabb ) ) {
                /*var aabb1=contact.shape1.aabb;
                var aabb2=contact.shape2.aabb;
                if(
	                aabb1.minX&gt;aabb2.maxX || aabb1.maxX&lt;aabb2.minX ||
	                aabb1.minY&gt;aabb2.maxY || aabb1.maxY&lt;aabb2.minY ||
	                aabb1.minZ&gt;aabb2.maxZ || aabb1.maxZ&lt;aabb2.minZ
                ){*/
                    //var next = contact.next;
                    this.removeContact( contact );
                    //contact = next;
                    continue;
                }
            }
            var b1 = contact.body1;
            var b2 = contact.body2;

            if( b1.isDynamic &amp;&amp; !b1.sleeping || b2.isDynamic &amp;&amp; !b2.sleeping ) contact.updateManifold();
            
            this.numContactPoints += contact.manifold.numPoints;
            contact.persisting = false;
            contact.constraint.addedToIsland = false;
           // contact = contact.next;

        }

        if( stat ) this.performance.calcNarrowPhase();

        //------------------------------------------------------
        //   SOLVE ISLANDS
        //------------------------------------------------------

        var invTimeStep = 1 / this.timeStep;
        var constraint;

        i = this.joints.length;
        while( i-- ){
            this.joints[i].addedToIsland = false;
        }


        // clear old island array
        this.islandRigidBodies = [];
        this.islandConstraints = [];
        this.islandStack = [];

        if( stat ) this.performance.setTime( 1 );

        this.numIslands = 0;

        // build and solve simulation islands
        i = this.rigidBodies.length;
        //while( body !== null ){
        while( i-- ){
            base = this.rigidBodies[i]; 
        //for( var base = this.rigidBodies; base !== null; base = base.next ){

            if( base.addedToIsland || base.isStatic || base.sleeping ) continue;// ignore
            
            if( base.isLonely() ){// update single body
                if( base.isDynamic ){
                    base.linearVelocity.addTime( this.gravity, this.timeStep );
                    /*base.linearVelocity.x+=this.gravity.x*this.timeStep;
                    base.linearVelocity.y+=this.gravity.y*this.timeStep;
                    base.linearVelocity.z+=this.gravity.z*this.timeStep;*/
                }
                if( this.callSleep( base ) ) {
                    base.sleepTime += this.timeStep;
                    if( base.sleepTime &gt; 0.5 ) base.sleep();
                    else base.updatePosition( this.timeStep );
                }else{
                    base.sleepTime = 0;
                    base.updatePosition( this.timeStep );
                }
                this.numIslands++;
                continue;
            }

            var islandNumRigidBodies = 0;
            var islandNumConstraints = 0;
            var stackCount = 1;
            // add rigid body to stack
            this.islandStack[0] = base;
            base.addedToIsland = true;

            // build an island
            do{
                // get rigid body from stack
                body = this.islandStack[--stackCount];
                this.islandStack[stackCount] = null;
                body.sleeping = false;
                // add rigid body to the island
                this.islandRigidBodies[islandNumRigidBodies++] = body;
                if(body.isStatic) continue;


                
                // search connections
                j = body.contactLink.length;
                while(j--){
                    cs = body.contactLink[j];
                    var contact = cs.contact;
                    constraint = contact.constraint;
                    if( constraint.addedToIsland || !contact.touching ) continue;// ignore
                    
                    // add constraint to the island
                    this.islandConstraints[islandNumConstraints++] = constraint;
                    constraint.addedToIsland = true;
                    next = cs.body;

                    if(next.addedToIsland) continue;
                    
                    // add rigid body to stack
                    this.islandStack[stackCount++] = next;
                    next.addedToIsland = true;
                }

                k = body.jointLink.length;
                while(k--){

                    js = body.jointLink[k];
                    constraint = js.joint;

                    if( constraint.addedToIsland ) continue;// ignore
                    
                    // add constraint to the island
                    this.islandConstraints[islandNumConstraints++] = constraint;
                    constraint.addedToIsland = true;
                    next = js.body;

                    if( next.addedToIsland || !next.isDynamic ) continue;
                    
                    // add rigid body to stack
                    this.islandStack[stackCount++] = next;
                    next.addedToIsland = true;

                }
            } while( stackCount != 0 );

            // update velocities
            var gVel = new Vec3().addTime( this.gravity, this.timeStep );
            /*var gx=this.gravity.x*this.timeStep;
            var gy=this.gravity.y*this.timeStep;
            var gz=this.gravity.z*this.timeStep;*/
            j = islandNumRigidBodies;
            while (j--){
            //or(var j=0, l=islandNumRigidBodies; j&lt;l; j++){
                body = this.islandRigidBodies[j];
                if(body.isDynamic){
                    body.linearVelocity.addEqual(gVel);
                    /*body.linearVelocity.x+=gx;
                    body.linearVelocity.y+=gy;
                    body.linearVelocity.z+=gz;*/
                }
            }

            // randomizing order
            if(this.enableRandomizer){
                //for(var j=1, l=islandNumConstraints; j&lt;l; j++){
                j = islandNumConstraints;
                while(j--){ if(j!==0){     
                        var swap = (this.randX=(this.randX*this.randA+this.randB&amp;0x7fffffff))/2147483648.0*j|0;
                        constraint = this.islandConstraints[j];
                        this.islandConstraints[j] = this.islandConstraints[swap];
                        this.islandConstraints[swap] = constraint;
                    }
                }
            }

            // solve contraints

            j = islandNumConstraints;
            while(j--){
            //for(j=0, l=islandNumConstraints; j&lt;l; j++){
                this.islandConstraints[j].preSolve( this.timeStep, invTimeStep );// pre-solve
            }
            k = this.numIterations;
            while(k--){
            //for(var k=0, l=this.numIterations; k&lt;l; k++){
                j = islandNumConstraints;
                while(j--){
                //for(j=0, m=islandNumConstraints; j&lt;m; j++){
                    this.islandConstraints[j].solve();// main-solve
                }
            }
            j = islandNumConstraints;
            while(j--){
            //for(j=0, l=islandNumConstraints; j&lt;l; j++){
                this.islandConstraints[j].postSolve();// post-solve
                this.islandConstraints[j] = null;// gc
            }

            // sleeping check

            var sleepTime = 10;
            j = islandNumRigidBodies;
            while(j--){
            //for(j=0, l=islandNumRigidBodies;j&lt;l;j++){
                body = this.islandRigidBodies[j];
                if( this.callSleep( body ) ){
                    body.sleepTime += this.timeStep;
                    if( body.sleepTime &lt; sleepTime ) sleepTime = body.sleepTime;
                }else{
                    body.sleepTime = 0;
                    sleepTime = 0;
                    continue;
                }
            }
            if(sleepTime &gt; 0.5){
                // sleep the island
                j = islandNumRigidBodies;
                while(j--){
                //for(j=0, l=islandNumRigidBodies;j&lt;l;j++){
                    this.islandRigidBodies[j].sleep();
                    this.islandRigidBodies[j] = null;// gc
                }
            }else{
                // update positions
                j = islandNumRigidBodies;
                while(j--){
                //for(j=0, l=islandNumRigidBodies;j&lt;l;j++){
                    this.islandRigidBodies[j].updatePosition( this.timeStep );
                    this.islandRigidBodies[j] = null;// gc
                }
            }
            this.numIslands++;
        }

        //------------------------------------------------------
        //   END SIMULATION
        //------------------------------------------------------

        if( stat ) this.performance.calcEnd();

    },

    /**
    * add someting to world
    */

    add: function( o ){
        
        o = o || {};

        var type = o.type || &quot;box&quot;;
        if( type.constructor === String ) type = [ type ];
        var isJoint = type[0].substring( 0, 5 ) === &#x27;joint&#x27; ? true : false;

        if( isJoint ) return this.initJoint( type[0], o );
        else return this.initBody( type, o );

    },

    initBody: function( type, o ){

        var invScale = this.invScale;

        // body dynamic or static
        var move = o.move || false;
        
        // body position
        var p = o.pos || [0,0,0];
        p = p.map(function(x) { return x * invScale; });

        // body size 
        var s = o.size === undefined ? [1,1,1] : o.size;
        if(s.length == 1){ s[1] = s[0]; }
        if(s.length == 2){ s[2] = s[0]; }
        s = s.map(function(x) { return x * invScale; });

        // body rotation in degree
        var r = o.rot || [0,0,0];
        r = r.map( function(x) { return x * _Math.degtorad; } );

        // body physics settings
        var sc = new ShapeConfig();
        // The density of the shape.
        if( o.density !== undefined ) sc.density = o.density;
        // The coefficient of friction of the shape.
        if( o.friction !== undefined ) sc.friction = o.friction;
        // The coefficient of restitution of the shape.
        if( o.restitution !== undefined ) sc.restitution = o.restitution;
        // The bits of the collision groups to which the shape belongs.
        if( o.belongsTo !== undefined ) sc.belongsTo = o.belongsTo;
        // The bits of the collision groups with which the shape collides.
        if( o.collidesWith !== undefined ) sc.collidesWith = o.collidesWith;

        if(o.config !== undefined ){
            if( o.config[0] !== undefined ) sc.density = o.config[0];
            if( o.config[1] !== undefined ) sc.friction = o.config[1];
            if( o.config[2] !== undefined ) sc.restitution = o.config[2];
            if( o.config[3] !== undefined ) sc.belongsTo = o.config[3];
            if( o.config[4] !== undefined ) sc.collidesWith = o.config[4];
        }


        if(o.massPos){
            o.massPos = o.massPos.map(function(x) { return x * invScale; });
            sc.relativePosition.set( o.massPos[0], o.massPos[1], o.massPos[2] );
        }
        if(o.massRot){
            o.massRot = o.massRot.map(function(x) { return x * degtorad; });
            sc.relativeRotation = _Math.EulerToMatrix( o.massRot[0], o.massRot[1], o.massRot[2] );
        }

        var position = new Vec3( p[0], p[1], p[2] );
        var rotation = new Quat().setFromEuler( r[0], r[1], r[2] );
        
        // rigidbody
        var body = new RigidBody( position, rotation, this.scale, this.invScale );

        // shapes
        var shapes = [];

        var n;
        for(var i=0; i&lt;type.length; i++){
            n = i*3;
            switch(type[i]){
                case &quot;sphere&quot;: shapes[i] = new SphereShape(sc, s[n]); break;
                case &quot;cylinder&quot;: shapes[i] = new CylinderShape(sc, s[n], s[n+1]); break;
                case &quot;box&quot;: shapes[i] = new BoxShape(sc, s[n], s[n+1], s[n+2]); break;
            }
            body.addShape( shapes[i] );
            if( i &gt; 0 ){
                if( p[n] ) shapes[i].relativePosition = new Vec3( p[n], p[n+1], p[n+2] );
                if( r[n] ) {
                    var q = new Quat().setFromEuler( r[n], r[n+1], r[n+2] );
                    shapes[i].relativeRotation = new Mat33().setQuat(q);
                }
            }
        } 
        
        // body static or dynamic
        if( move ){

            if(o.massPos || o.massRot) body.setupMass( BODY_DYNAMIC, false );
            else body.setupMass( BODY_DYNAMIC, true );

            // body can sleep or not
            if( o.neverSleep ) body.allowSleep = false;
            else body.allowSleep = true;

        } else {

            body.setupMass( BODY_STATIC );

        }
        
        if( o.name !== undefined ) body.name = o.name;
        else if( o.move ) body.name = this.rigidBodies.length;
        
        // finaly add to physics world
        this.addRigidBody( body );

        // force sleep on not
        if( move ){
            if( o.sleep ) body.sleep();
            else body.awake();
        }

        return body;

    },

    initJoint: function( type, o ){

        var invScale = this.invScale;

        var axe1 = o.axe1 || [1,0,0];
        var axe2 = o.axe2 || [1,0,0];
        var pos1 = o.pos1 || [0,0,0];
        var pos2 = o.pos2 || [0,0,0];

        pos1 = pos1.map( function ( x ) { return x * invScale; } );
        pos2 = pos2.map( function ( x ) { return x * invScale; } );

        var min, max;
        if( type === &quot;jointDistance&quot; ){
            min = o.min || 0;
            max = o.max || 10;
            min = min * invScale;
            max = max * invScale;
        }else{
            min = o.min || 57.29578;
            max = o.max || 0;
            min = min * _Math.degtorad;
            max = max * _Math.degtorad;
        }

        var limit = o.limit || null;
        var spring = o.spring || null;
        var motor = o.motor || null;

        // joint setting
        var jc = new JointConfig();
        jc.scale = this.scale;
        jc.invScale = this.invScale;
        jc.allowCollision = o.collision || false;
        jc.localAxis1.set( axe1[0], axe1[1], axe1[2] );
        jc.localAxis2.set( axe2[0], axe2[1], axe2[2] );
        jc.localAnchorPoint1.set( pos1[0], pos1[1], pos1[2] );
        jc.localAnchorPoint2.set( pos2[0], pos2[1], pos2[2] );

        var b1 = null;
        var b2 = null;

        if( o.body1 === undefined || o.body2 === undefined ) return Error(&#x27;World&#x27;, &quot;Can&#x27;t add joint if attach rigidbodys not define !&quot; );

        if ( o.body1.constructor === String ) { b1 = this.getByName( o.body1 ); }
        else if ( o.body1.constructor === Number ) { b1 = this.getByName( o.body1 ); }
        else if ( o.body1.constructor === RigidBody ) { b1 = o.body1; }

        if ( o.body2.constructor === String ) { b2 = this.getByName( o.body2 ); }
        else if ( o.body2.constructor === Number ) { b2 = this.getByName( o.body2 ); }
        else if ( o.body2.constructor === RigidBody ) { b2 = o.body2; }

        if( b1 === null || b2 === null ) return Error(&#x27;World&#x27;, &quot;Can&#x27;t add joint attach rigidbodys not find !&quot; );

        jc.body1 = b1;
        jc.body2 = b2;

        var joint;
        switch( type ){
            case &quot;jointDistance&quot;: joint = new DistanceJoint(jc, min, max); 
                if(spring !== null) joint.limitMotor.setSpring(spring[0], spring[1]);
                if(motor !== null) joint.limitMotor.setMotor(motor[0], motor[1]);
            break;
            case &quot;jointHinge&quot;: case &quot;joint&quot;: joint = new HingeJoint(jc, min, max);
                if(spring !== null) joint.limitMotor.setSpring(spring[0], spring[1]);// soften the joint ex: 100, 0.2
                if(motor !== null) joint.limitMotor.setMotor(motor[0], motor[1]);
            break;
            case &quot;jointPrisme&quot;: joint = new PrismaticJoint(jc, min, max); break;
            case &quot;jointSlide&quot;: joint = new SliderJoint(jc, min, max); break;
            case &quot;jointBall&quot;: joint = new BallAndSocketJoint(jc); break;
            case &quot;jointWheel&quot;: joint = new WheelJoint(jc);  
                if(limit !== null) joint.rotationalLimitMotor1.setLimit(limit[0], limit[1]);
                if(spring !== null) joint.rotationalLimitMotor1.setSpring(spring[0], spring[1]);
                if(motor !== null) joint.rotationalLimitMotor1.setMotor(motor[0], motor[1]);
            break;
        }

        joint.name = o.name || &#x27;&#x27;;
        // finaly add to physics world
        this.addJoint( joint );

        return joint;

    },


} );

export { World };
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
